<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hacker Terminal — Consent-based Sender</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
<style>
  :root { --bg:#000; --neon:#00ff66; --muted:#082; }
  html,body { height:100%; margin:0; background:var(--bg); color:var(--neon); font-family: "Courier New", monospace; }
  .container-main { min-height:100vh; display:flex; align-items:center; justify-content:center; padding:2rem; }
  .card-hack { width:100%; max-width:1100px; border:2px solid rgba(0,255,102,0.08); background:linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.85)); box-shadow:0 0 40px rgba(0,255,102,0.04); }
  .header { padding:1rem 1.25rem; border-bottom:1px dashed rgba(0,255,102,0.04); display:flex; justify-content:space-between; align-items:center; }
  .terminal { background:#000000cc; min-height:200px; max-height:360px; overflow:auto; padding:1rem; border-top:1px dashed rgba(0,255,102,0.03); }
  .term-line { line-height:1.35; white-space:pre-wrap; color:rgba(0,255,102,0.95); }
  .controls { padding:1rem; display:flex; gap:.75rem; flex-wrap:wrap; align-items:center; }
  .video-preview { width:100%; height:220px; background:#071; border:1px solid rgba(0,255,102,0.06); object-fit:cover; }
  .map-mini { width:100%; height:220px; border:1px solid rgba(0,255,102,0.06); }
  .badge-consent { background:rgba(0,255,102,0.04); color:var(--neon); border:1px solid rgba(0,255,102,0.04); }
  .spinner-wrap { display:flex; gap:.5rem; align-items:center; }
  .caret { display:inline-block; width:.8ch; background:var(--neon); margin-left:.25ch; animation:blink 1s steps(2) infinite; }
  @keyframes blink { 0%,50%{opacity:1} 51%,100%{opacity:0} }
  @media (min-width:992px) { .layout-grid { display:grid; grid-template-columns: 1fr 400px; gap:1rem; } }
  small.note { color:rgba(0,255,102,0.45); }
</style>
</head>
<body>
  <main class="container-main">
    <div class="card card-hack p-0">
      <div class="header">
        <div>
          <h4 class="m-0">[ HACKER ACCESS TERMINAL — Consent Mode ]</h4>
          <small class="note">This will only access devices after explicit consent and will send photo+location to the configured Telegram bot.</small>
        </div>
        <div class="text-end">
          <span class="badge badge-consent px-2 py-1">Explicit Consent Required</span>
        </div>
      </div>

      <div class="p-3 layout-grid">
        <div>
          <div class="terminal" id="terminal" aria-live="polite"></div>

          <div class="mt-3">
            <video id="camera" class="video-preview" autoplay playsinline muted></video>
            <canvas id="snapshot" style="display:none;"></canvas>
          </div>

          <div class="controls mt-3">
            <div class="form-check">
              <input class="form-check-input" type="checkbox" id="chkConsent">
              <label class="form-check-label" for="chkConsent" style="color:var(--neon);">I give explicit consent to capture a photo and share my current GPS coordinates with the bot for research/prank purposes.</label>
            </div>
            <button id="btnStart" class="btn btn-sm btn-outline-success" disabled>Start (Request Permissions)</button>
            <button id="btnSend" class="btn btn-sm btn-outline-primary" disabled>Send Photo & Location</button>

            <div id="loader" style="display:none" class="spinner-wrap ms-auto">
              <div class="spinner-border spinner-border-sm" role="status"></div>
              <small style="color:rgba(0,255,102,0.7)">Sending to bot...</small>
            </div>
          </div>
        </div>

        <div>
          <div>
            <strong>GPS Coordinates</strong>
            <div id="gps" style="margin-top:.5rem; color:rgba(0,255,102,0.9)">— not available —</div>
          </div>

          <div class="mt-3">
            <strong>Map Mini</strong>
            <iframe id="map" class="map-mini" src="" loading="lazy" referrerpolicy="no-referrer"></iframe>
          </div>

          <div class="mt-3">
            <strong>Snapshot Preview</strong>
            <div style="margin-top:.5rem">
              <img id="previewImg" src="" style="max-width:100%; border:1px solid rgba(0,255,102,0.06); display:none" alt="snapshot preview">
              <small id="previewText" style="color:rgba(0,255,102,0.6)">No snapshot yet</small>
            </div>
          </div>

        </div>
      </div>

      <div class="p-3">
        <div class="d-flex justify-content-between align-items-center">
          <small class="note">Token is included client-side for demo; consider server-side proxy for production.</small>
          <div>
            <button id="btnShowResp" class="btn btn-sm btn-outline-light">Show API Response</button>
          </div>
        </div>
        <pre id="apiResp" style="margin-top:.75rem; background:#0009; padding:.75rem; border-radius:.4rem; display:none; color:var(--neon); max-height:200px; overflow:auto;"></pre>
      </div>
    </div>
  </main>

<script>
/*
  --- Configuration ---
  NOTE: Token is present client-side here for demo. For production, use a server-side proxy.
*/
const BOT_TOKEN = "7510022093:AAGjh35in3Y7Uy4YRoNBrl_h-DHEQiaRqaI"; // your bot token
const CHAT_ID  = "6950619919"; // your chat id

/* UI elements */
const chkConsent = document.getElementById('chkConsent');
const btnStart = document.getElementById('btnStart');
const btnSend = document.getElementById('btnSend');
const terminal = document.getElementById('terminal');
const camera = document.getElementById('camera');
const snapshotCanvas = document.getElementById('snapshot');
const previewImg = document.getElementById('previewImg');
const previewText = document.getElementById('previewText');
const gpsEl = document.getElementById('gps');
const mapFrame = document.getElementById('map');
const loader = document.getElementById('loader');
const apiResp = document.getElementById('apiResp');
const btnShowResp = document.getElementById('btnShowResp');

let mediaStream = null;
let lastCoords = null;
let lastBlob = null;
let lastApiResponses = [];

/* enable start only when consent checked */
chkConsent.addEventListener('change', () => {
  btnStart.disabled = !chkConsent.checked;
});

/* helper: append terminal lines (with typing effect) */
function appendTerminalLine(text, typing = false, cb = null) {
  const line = document.createElement('div');
  line.className = 'term-line';
  terminal.appendChild(line);
  terminal.scrollTop = terminal.scrollHeight;
  if (!typing) {
    line.textContent = text;
    if (cb) cb();
    return;
  }
  let idx = 0;
  const caret = document.createElement('span'); caret.className='caret';
  function tick() {
    line.textContent = text.slice(0, idx);
    line.appendChild(caret);
    idx++;
    if (idx > text.length) {
      line.removeChild(caret);
      if (cb) cb();
      return;
    }
    terminal.scrollTop = terminal.scrollHeight;
    setTimeout(tick, 20 + Math.random()*40);
  }
  tick();
}

/* start: request camera and location */
btnStart.addEventListener('click', async () => {
  btnStart.disabled = true;
  appendTerminalLine("[ACTION] Requesting camera permission...", true);
  try {
    mediaStream = await navigator.mediaDevices.getUserMedia({ video:true, audio:false });
    camera.srcObject = mediaStream;
    appendTerminalLine("[OK] Camera permission granted.");
    // capture snapshot after short warm-up
    setTimeout(captureSnapshot, 1500);
  } catch (err) {
    appendTerminalLine("[ERROR] Camera permission denied or not available: " + err.message);
  }

  appendTerminalLine("[ACTION] Requesting geolocation...", true);
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition((pos) => {
      const lat = pos.coords.latitude.toFixed(6);
      const lon = pos.coords.longitude.toFixed(6);
      lastCoords = { latitude: lat, longitude: lon };
      gpsEl.textContent = `${lat}, ${lon}`;
      appendTerminalLine(`[OK] Location: ${lat}, ${lon}`);
      updateMap(lat, lon);
      // enable send if we have snapshot or coords
      if (lastBlob) btnSend.disabled = false;
    }, (err) => {
      appendTerminalLine("[ERROR] Location denied or unavailable: " + err.message);
    }, { enableHighAccuracy:true, timeout:10000 });
  } else {
    appendTerminalLine("[ERROR] Geolocation not supported by browser.");
  }
});

/* capture snapshot from video */
function captureSnapshot() {
  if (!mediaStream) {
    appendTerminalLine("[WARN] No camera stream to capture.");
    return;
  }
  const track = mediaStream.getVideoTracks()[0];
  const settings = track.getSettings();
  const w = settings.width || 640;
  const h = settings.height || 480;
  snapshotCanvas.width = w;
  snapshotCanvas.height = h;
  const ctx = snapshotCanvas.getContext('2d');
  ctx.drawImage(camera, 0, 0, w, h);
  snapshotCanvas.toBlob((blob) => {
    lastBlob = blob;
    previewImg.src = URL.createObjectURL(blob);
    previewImg.style.display = 'block';
    previewText.style.display = 'none';
    appendTerminalLine("[OK] Snapshot captured (preview shown).");
    // enable send if coords exist
    if (lastCoords) btnSend.disabled = false;
  }, 'image/jpeg', 0.92);
}

/* update google maps mini */
function updateMap(lat, lon) {
  mapFrame.src = `https://www.google.com/maps?q=${lat},${lon}&z=16&output=embed`;
}

/* send photo and location to Telegram */
btnSend.addEventListener('click', async () => {
  if (!lastBlob && !lastCoords) {
    alert("No data to send. Capture snapshot and ensure location is available.");
    return;
  }
  btnSend.disabled = true;
  loader.style.display = 'flex';
  appendTerminalLine("[ACTION] Preparing payload...", true);

  try {
    // 1) Send photo via sendPhoto
    if (lastBlob) {
      appendTerminalLine("[ACTION] Uploading snapshot to Telegram...", true);
      const fd = new FormData();
      fd.append('chat_id', CHAT_ID);
      fd.append('photo', lastBlob, 'snapshot.jpg');

      const respPhoto = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
        method: 'POST', body: fd
      });
      const jsonPhoto = await respPhoto.json();
      lastApiResponses.push({ sendPhoto: jsonPhoto });
      if (jsonPhoto.ok) {
        appendTerminalLine("[SUCCESS] Photo sent to Telegram.");
      } else {
        appendTerminalLine("[ERROR] sendPhoto failed: " + (jsonPhoto.description || JSON.stringify(jsonPhoto)));
      }
    }

    // 2) Send location via sendLocation
    if (lastCoords) {
      appendTerminalLine("[ACTION] Sending location to Telegram...", true);
      const respLoc = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendLocation`, {
        method: 'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify({ chat_id: CHAT_ID, latitude: parseFloat(lastCoords.latitude), longitude: parseFloat(lastCoords.longitude) })
      });
      const jsonLoc = await respLoc.json();
      lastApiResponses.push({ sendLocation: jsonLoc });
      if (jsonLoc.ok) {
        appendTerminalLine("[SUCCESS] Location sent to Telegram.");
      } else {
        appendTerminalLine("[ERROR] sendLocation failed: " + (jsonLoc.description || JSON.stringify(jsonLoc)));
      }
    }

    appendTerminalLine("[DONE] Payload process finished.");
  } catch (err) {
    appendTerminalLine("[ERROR] Exception while sending: " + err.message);
  } finally {
    loader.style.display = 'none';
    btnSend.disabled = false;
    apiResp.style.display = 'none';
  }
});

/* show API response */
btnShowResp.addEventListener('click', () => {
  apiResp.style.display = apiResp.style.display === 'none' ? 'block' : 'none';
  if (lastApiResponses.length) {
    apiResp.textContent = JSON.stringify(lastApiResponses, null, 2);
  } else {
    apiResp.textContent = "No API responses yet.";
  }
});

/* cleanup on unload */
window.addEventListener('beforeunload', () => {
  if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());
});
</script>
</body>
</html>
